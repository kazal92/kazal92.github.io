[{"content":" 누구냐고 물을 IP를 요청하는 브로드캐스트 MAC에 대한 ARP 요청 생성   ARP를 사용하여 누가 대상 IP를 가지고 있는지 확인 목적지 MAC을 브로드캐스트 MAC으로 설정  testetestestsettet haha  broadcast = scapy.Ether(dst=\u0026ldquo;ff:ff:ff:ff:ff:ff\u0026rdquo;) broadcast.show() # 확인\n[https://www.guru99.com/linux-commands-cheat-sheet.html#2](https://www.guru99.com/linux-commands-cheat-sheet.html#2)   [Linux Command Cheat Sheet\nIn this Linux/Unix command line cheat sheet, you will learn: Basic Linux commands File Permission commands Environment Variables command User management commands of linux Networking command Process co\nwww.guru99.com](https://www.guru99.com/linux-commands-cheat-sheet.html#2)\n이 Linux/Unix 명령줄 치트 시트에서는 다음을 배우게 됩니다.\n 기본 Linux 명령 파일 권한 명령 환경 변수 명령 리눅스의 사용자 관리 명령어 네트워킹 명령 처리 명령 VI 편집 명령  기본 Linux 명령 명령설명\n   ls 현재 작업 디렉토리의 모든 파일과 디렉토리를 나열합니다.     ls -R 하위 디렉토리의 파일도 나열합니다.   ls -a 숨김 파일도 나열   ls -al 권한, 크기, 소유자 등과 같은 자세한 정보가 있는 파일 및 디렉토리를 나열합니다.   cd or cd ~ 홈 디렉토리로 이동   cd .. 한 단계 위로 이동   cd 특정 디렉토리로 변경하려면   cd / 루트 디렉토리로 이동   cat \u0026gt; filename 새 파일을 만듭니다.   cat filename 파일 내용을 표시합니다   cat file1 file2 \u0026gt; file3 두 개의 파일(file1, file2)을 결합하고 새 파일(file3)에 출력을 저장합니다.   mv file \u0026ldquo;new file path\u0026rdquo; 파일을 새 위치로 이동합니다.   mv filename new_file_name 파일 이름을 새 파일 이름으로 바꿉니다.   sudo 일반 사용자가 수퍼유저 또는 루트의 보안 권한으로 프로그램을 실행할 수 있습니다.   rm filename 파일 삭제   man 명령에 대한 도움말 정보 제공   history 현재 터미널 세션에 입력된 모든 과거 명령 목록을 제공합니다.   clear 터미널을 지웁니다.   mkdir directoryname 현재 작업 디렉토리 또는 지정된 경로에 새 디렉토리를 만듭니다.   rmdir 디렉토리를 삭제합니다   mv 디렉토리 이름 바꾸기   pr -x 파일을 x 열로 나눕니다.   pr -h 파일에 헤더를 할당   pr -n 줄 번호가 있는 파일을 나타냅니다.   lp -nc , lpr c 파일의 \u0026ldquo;c\u0026rdquo; 사본을 인쇄합니다.    lp-d lp-P 프린터의 이름을 지정합니다   apt-get 패키지 설치 및 업데이트에 사용되는 명령   mail -s \u0026lsquo;subject\u0026rsquo; -c \u0026lsquo;cc-address\u0026rsquo; -b \u0026lsquo;bcc-address\u0026rsquo; \u0026rsquo;to-address\u0026rsquo; 이메일을 보내는 명령   mail -s \u0026ldquo;Subject\u0026rdquo; to-address \u0026lt; Filename 첨부 파일이 있는 이메일을 보내는 명령    파일 권한 명령 명령설명\n   ls -l 파일 형식 및 액세스 권한 표시     r 읽기 권한   w 쓰기 권한   x 실행 권한   -= 비허가   Chown user 파일/디렉토리의 소유권을 변경하려면   Chown user:group filename 파일 또는 디렉토리에 대한 사용자 및 그룹 변경    환경 변수 명령 명령설명\n   echo $VARIABLE 변수의 값을 표시하려면     env 모든 환경 변수를 표시합니다.   VARIABLE_NAME= variable_value 새 변수 생성   Unset 변수 제거   export Variable=value 환경 변수의 값을 설정하려면    리눅스의 사용자 관리 명령어 명령설명\n   sudo adduser username 새 사용자를 추가하려면     sudo passwd -l \u0026lsquo;username\u0026rsquo; 사용자의 비밀번호를 변경하려면   sudo userdel -r \u0026lsquo;username\u0026rsquo; 새로 생성된 사용자를 제거하려면   sudo usermod -a -G GROUPNAME USERNAME 그룹에 사용자를 추가하려면   sudo deluser USER GROUPNAME 그룹에서 사용자를 제거하려면   finger 로그인한 모든 사용자의 정보를 표시합니다.   finger username 특정 사용자의 정보 제공    네트워킹 명령 명령설명\n   SSH username@ip-address or hostname SSH를 사용하여 원격 Linux 시스템에 로그인     Ping hostname=\u0026quot;\u0026quot; or =\u0026quot;\u0026quot; 네트워크 및 호스트 연결을 ping하고 분석하려면   dir 원격 컴퓨터의 현재 디렉토리에 있는 파일 표시   cd \u0026ldquo;dirname\u0026rdquo; 원격 컴퓨터에서 디렉토리를 \u0026ldquo;dirname\u0026quot;으로 변경   put file 로컬에서 원격 컴퓨터로 \u0026lsquo;파일\u0026rsquo; 업로드   get file 원격 컴퓨터에서 로컬 컴퓨터로 \u0026lsquo;파일\u0026rsquo; 다운로드   quit 로그 아웃    처리 명령 명령설명\n   bg 프로세스를 백그라운드로 보내려면     fg 중지된 프로세스를 포그라운드에서 실행하려면   top 모든 활성 프로세스에 대한 세부 정보   ps 사용자에 대해 실행 중인 프로세스의 상태 제공   ps PID 특정 프로세스의 상태를 제공합니다.   pidof 프로세스의 프로세스 ID(PID)를 제공합니다.   kill PID 프로세스 종료   nice 주어진 우선 순위로 프로세스를 시작합니다.   renice 이미 실행 중인 프로세스의 우선 순위 변경   df 시스템에 여유 하드 디스크 공간을 제공합니다.   free 시스템에 여유 RAM 제공    VI 편집 명령 명령설명\n   i 커서 위치에 삽입(삽입 모드로 전환)     a 커서 뒤에 쓰기(삽입 모드로 전환)   A 줄 끝에 쓰기(삽입 모드로 전환)   ESC 삽입 모드 종료   u 마지막 변경 취소   U 전체 라인에 대한 모든 변경 사항 실행 취소   o 새 줄 열기(삽입 모드로 전환)   dd 라인 삭제   3dd 3줄 삭제   D 커서 다음 줄의 내용 삭제   C 커서 뒤에 있는 줄의 내용을 삭제하고 새 텍스트를 삽입합니다. ESC 키를 눌러 삽입을 종료합니다.   dw 단어 삭제   4dw 4단어 삭제   cw 단어 변경   x 커서에서 문자 삭제   r 문자 바꾸기   R 커서부터 문자 덮어쓰기   s 커서 아래에 한 문자를 대체하여 계속 삽입   S 전체 줄을 대체하고 줄의 시작 부분에 삽입 시작   ~ 개별 문자의 대소문자 변경    ","date":"2022-04-04T07:59:37+09:00","permalink":"https://kazal92.github.io/arp/","title":"ARP"},{"content":"1. ADB ADB 사용하기\nhttps://forum.xda-developers.com/t/tool-minimal-adb-and-fastboot-2-9-18.2317790/\nadb shell\nadb devices  옵션\n-e : 에뮬레이터\n-d : USB 장치\n-s : adb -s \u0026lt;장치명\u0026gt; \u0026lt;명령어\u0026gt;\n 설치치된 패키지 찾기\n\u0026gt;adb shell pm list packages | find \u0026#34;\u0026lt;패키지 이름이나 키워드\u0026gt;\u0026#34; apk의 정확한 패키지 이름 확인 후, apk 설치 위치를 확인합니다.\n\u0026gt;adb shell dumpsys package \u0026lt;패키지 이름\u0026gt; | find \u0026#34;path\u0026#34; adb 기본 명령어(?) adb devices adb connect 127.0.0.1:62001 adb shell 로그 분석 adb logcat : 안드로이드 장치에서 발생하는 로그메시지 출력  adb logcat --pid=\u0026lt;pid\u0026gt; : 특정 프로세스 로그만 출력 프로세스 목록 확인 adb jdwp  // 해당 어플 실행전 adb jdwp 결과값과 실행후 결과값을 비교하여 추가된 PID로 분석 어플리케이션 제어 **// 어플리케이션 설치** adb install \u0026lt;apk_파일\u0026gt;  **// 동일한 어플리케이션 설치되어있을경우 기존데이터 삭제 없이 설치** adb -r install \u0026lt;apk_파일\u0026gt; | grep \u0026lt;설치된 어플리케이션\u0026gt;  **//설치된 어플리케이션 패키지 목록** adb shell pm list packages -f  **// 어플리케이션 삭제** adb uninstall \u0026lt;설치된패키지명\u0026gt; 파일제어 **// 에뮬레이터/장치 → PC로 파일 복사** adb pull \u0026lt;장치 경로\u0026gt; \u0026lt;pc저장 위치\u0026gt;  **// PC -\u0026gt; 에뮬레이터/장치로 파일 복사** adb push \u0026lt;pc파일위치\u0026gt; \u0026lt;장치저장 위치\u0026gt; 포트와 네트워킹 **// 로컬 포트를 안드로이드 장치의 특정 포트와 소켓 통신** adb forward \u0026lt;로컬\u0026gt; \u0026lt;원격지\u0026gt; adb forwoard tcp:7777 tcp:8888  **// 디버깅** adb forwoard tcp:7777 jdwp:1824 jdb -sourcepath \u0026lt;경로\u0026gt; -connect 스크립팅 **// 장치 시리얼 번호 출력** adb get-serialno  **// 장치 상태 문자열로 출력** adb get-state  **// 장치 구동시 명령어 실행** adb wait-for-device \u0026lt;명령어\u0026gt; 서버 **// ADB 서버 프로세스 동작여부 확인후 결과 표시, 동작중이지 않으면 서버 구동시킴** adb start-server  **// 서버종료** adb kill-server 버그 보고서 adb bugreport ","date":"2022-04-01T08:43:09+09:00","permalink":"https://kazal92.github.io/android/adb-%EC%82%AC%EC%9A%A9%EB%B2%95/","title":"ADB 사용법"},{"content":"Android 취약점  android App 기능 혹은 잘못된 설정에 의한 취약점  Android 취약점 관련 진단 항목 (금취분평 기준)\n 화면 강제실행에 의한 인증단계 우회 인증 및 인가 관련 항목 정보 노출 관련 항목  Android 취약점 발견 위치\n Activity Broadcase Receiver Content Provider   Activity 컴포넌트 취약점 Android Activity는 화면에 표시되는 UI 구성을 위해 가장 기본이 되는 요소이며, 각각 독립적으로 동작하기 때문에 보안적으로 취약하게 선언되어 있을 경우, 원하는 activity를 강제로 호출 가능한 취약점\n위협  공격자가 필요한 Activity를 강제로 호출하며 , 해당 취약점을 악용하는 경우 인증절차를 우회하여 권한이 없는 Activity에 접근하여 특정 기능을 사용할 수 있음  진단방법 ADB활용 Activity 취약점 확인\n  AndroidManifest.xml 확인\nactivity android:exported=\u0026quot;true\u0026quot; 다른 애플리케이션에서 activity 실행 가능\nactivity android:exported=\u0026quot;false\u0026quot; 동일한 애플리케이션 또는 UID를 가진 애플리케이션에서만 실행 가능\n  ADB를 이용한 Activity 실행 (am 명령어 사용)\nadb shell am start -n 패키지명/.Activity 경로\n활성화 된 Activity 내 기능 사용 가능 확인  \n  Drozer 활용 Activity 취약점 확인  \n대응방안  노출된 Activity에 바로 접근하지 못하도록 exported 속성을 false로 변경  진단 시 주의사항 및 팁  진단 시 AndroidManifest.xml 파일을 잘 분석해야하며, 여기서 해당 취약점이 존재하는지 파악할 수 있음 인증과 관련된 Activity에서 해당 취약점이 많이 발견됨   Broadcase Receiver 취약점  Android Broadcase Receiver는 백그라운드에서 대기하고 있다가 이벤트 발생 시 시스템에서 전달한 메시지 Intent를 모든 애플리케이션에게 전달하는 역할. 메시지를 수신한 애플리케이션은 그에 맞는 응답 메시지를 사용자에게 전달\n위협  공격자는 시스템 대신 임의의 악의적인 메시지를 특정 애플리케이션의 노출된 Receiver에 전송하여 응답오는 데이터를 가로채는 행위를 할 수 있음 응답되는 데이터에 애플리케이션이 가지고 있는 중요정보(개인정보, 계정정보)가 포함되어 있을 경우 탈취 가능   \n진단방법 ADB활용 Boradcase Receiver 취약점 확인\n AndroidManifest.xml 확인\nreceiver android:exported=\u0026quot;true\u0026quot; -\u0026gt; 다른 애플리케이션에서 intent 가능\n ADB를 이용한 BroadCase 생성 (am 명령어 사용) adb shell am broadcase -a Action_name -n 패키지명/.Receiver경로   \nBroadcase 생성 결과는 App 구현에 따라 다르며, App log 정보(logcat)나 App 알람을 통해 확인 가능\n대응방안  노출된 Broadcase Receiver에 외부 애플리케이션에서 발생하는 intent에 영향을 받지 않도록 exported 속성을 false로 변경 각 Receiver 별로 권한(Permission)을 주어 외부 애플리케이션에 대한 접근 권한을 관리  진단 시 주의사항 및 팁  진단 시 Androidmanifest.xml 파일을 잘 분석해야하며, 여기서 해당 취약점이 존재하는지 파악할 수 있음   Content Provider 취약점  Content Provider는 다른 애플리케이션의 데이터베이스나 파일에 접글할 수 있는 인터페이스를 제공, 허용된 데이터, 파일에만 접근 가능하도록 하는 권한 설정이 부재일 때 발생하는 취약점\n위협  공격자는 사용자가 공유하기를 원하는 데이터 외 데이터에 비정상적으로 접근하여 중요한떼이터 조회/변경 등 악의적인 행동을 할 수 있음   \n진단방법 ADB 활용 Content Provider 취약점 확인\n  AndroidManifest.xml 확인\nprovider android:exported=\u0026quot;true\u0026quot; -\u0026gt; 다른 애플리케이션에서 provider 실행 가능 provider android:exported=\u0026quot;false\u0026quot; -\u0026gt; 동일한 애플리케이션 또는 UID를 가진 애플리케이션에서만 실행 가능 \n  Content URI 탐색\n디컴파일한 소스코드 내 노출된 Content URI를 검색 (keyword: content://)\n  ADB를 이용한 Cotent Provider 확인\nadb shell content query --uri content경로 -\u0026gt; 2번에서 확인된 경로\n    -\u0026gt; 외부 애플리케이션에서 providerd에 노출된 content에 접근하여 user 로그인 로그를 확인할 수 있다\nDrozer 활용 Content Provider 취약점 확인    \n대응방안  Content Provider에 안전한 Permission을 설정 (protectionLevel 속성 이용)\nnomal : protectionLevel의 기본 값으로서 단순히 기능을 사용하기 위한 식별 값으로 사용되는 퍼미션\ndangerous : 사용자 개인 데이터나 시스템 제어 기능을 식별하는 퍼미션\nsignature : 동일한 서명 값으로 컴파일 된 앱끼리 기능을 허용하고자 할 때 사용하는 퍼미션\nsystem : 안드로이드 시스템 이미지로 설치되는 앱을 허용 할 때 사용하는 퍼미션  진단 시 주의사항 및 팁  진단 시 Androidmanifest.xml 파일을 잘 분석해야하며, 여기서 해당 취약점이 존재하는지 파악할 수 있음  ","date":"2022-04-01T07:00:11+09:00","permalink":"https://kazal92.github.io/android/android_%EC%B7%A8%EC%95%BD%EC%A0%90/","title":"Android 취약점"},{"content":"App 데이터 변조 진단  App이 서버와 통신하는 데이터 혹은 앱 내부에서 전달되는 함수 인자, 반환값 데이터 등을 변조하여 App 실행 흐름을 바꾸거나, 개발자가 의도하지 않은 동작을 유발할 수 있음 인증 우회나 인젝션 등 App 서비스에 대한 공격이 데이터 변조로 주로 이루어짐  데이터 변조에 관련된 진단 항목(금취분평 기준)\n 데이터를 변조하는 모든 진단 항목 (SQL 인젝션 , 인증, 인가와 관련된 취약점 등)  데이터 변조 위치\n 네트워크 통신 데이터 변조 : TCP 통신, HTTP 통신 메모리 내 데이터 변조 : 함수 인자, 반환값, 메모리 영역 데이터 변조    네트워크 통신 구간 데이터 변조   App 서버와 통신을 하는 과정에서 통신 데이터를 분석하고, 데이터를 변조함으로써 인증 우회, 파라미터 변조 등 다양한 공격을 수행 할 수 있음  네트워크 통신  TCP 통신\nNative App, Hybrid App에서 앱 서버와 HTTP 통신이 아닌 TCP 통신을 하여 데이터를 주고 받는 경우가 있음. 이럴 경우 TCP Proxy를 사용하여 통신 데이터 분석 및 데이터 변조하여 진단 해야함\n HTTP 통신\nWeb App, Hybrid App에서 웹 서버와 HTTP 통신을 하여 데이터를 주고 받는 경우가 있음. 이럴 경우 HTTP Proxy를 사용하여 통신 데이터 분석 및 데이터 변조를 하여 진단해야 함   메모리 데이터 변조   App 실행 중 함수의 인자값 혹은 반환값, 임의 함수 실행 및 조작을 통해 App 클라이언트에서 이루어지는 인증 로직을 우회할 수 있고, App의 실행 흐름을 조작할 수 있음  메모리 데이터 변조 방법  DBI(Dynamic Binary Instrument) 사용 : Frida  메모리 데이터 변조 이용  App Function 인자값\u0026리턴값 변조  \n   App so Library Function 후킹 (Dynamic Load) // 특정 라이브러리가 로드 되었을 때, 후킹하고 싶은 경우 send(\u0026#34;[*] Injected JS\u0026#34;);  var didHookapis = false;  // if it used \u0026#34;System.loadLibrary\u0026#34;, we have hokk \u0026#34;android_dlopen_ext\u0026#34; Interceptor.attach(Module.findExportByName(null, \u0026#39;dlopen\u0026#39;), {  onEnter: function(args)  {  this.path = Memory.readUtf8String(args[0]);  console.log(this.path);  },  onLeave: function(retval)  {  if(!retval.isNull() \u0026amp;\u0026amp; this.path.indexOf(\u0026#39;libdivajni.so\u0026#39;) !== -1 \u0026amp;\u0026amp; !didHookapis){  didHookapis = true;  console.log(\u0026#34;File loaded hooking\u0026#34;);  so_hook();  }  } });  function so_hook(){  var so_target = Module.findExportByName(\u0026#34;libdivajni.so\u0026#34;,\u0026#34;Java_jakhar_aseem_diva_DivaJni_initiateLaunchSequence\u0026#34;);  Interceptor.attach(so_target, {  onLeave: function(retval)  {  retval.replace(1);  send(\u0026#34;Function Called!!\u0026#34;);  }  }); }    App Function 재정의  \n   App Function 호출  \n  ","date":"2022-04-01T06:19:08+09:00","permalink":"https://kazal92.github.io/android/data-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B3%80%EC%A1%B0/","title":"Android App 데이터 변조"},{"content":"정보 노출 진단  App의 동작으로 인해 노출 되서는 안되는 정보들이 노출되는 취약점 App이 실행 중 사용자의 개인정보, 중요정보를 단말기에 저장할 경우, 단말기가 공격자에 의해 탈취 당하거나 악성 앱이 설치되어 단말기에 저장된 중요정보들이 노출될 수 있음 App 통신 패킷이나 실행 파일에서 서버의 중요정보들이 노출되어 2차 공격에 이용될 수 있음  정보 노출의 위험도\n 서버의 중요 정보의 중요도에 따라 위험도는 높아질 수 있음 단말기 내에서 노출되는 개인정보, 중요정보 등은 실제 공격에서는 가정되어야 하는 조건(루팅, 잠금 설정 우회 등)이 많지만 무시할 수 없음  정보 노출관련된 진단 항목 (금취분평 기준)\n금취분평 pdf 구해보자..;\n   소스 코드에서의 정보노출  App 바이트 코드(dex), 디컴파일 소스 내에 존재하는 문자열에서 중요정보가 노출됨\n주요 노출정보  string keyword : ip, port, user, password, key, http 등 내부 연동 서버 IP 및 포트 정보 관리자 계정 관리자 페이지 정보(URL) DB 서버 및 계정 정보  App 바이트 코드 내 String 추출 App 바이트 코드를 추출하여 바이트 코드내 String 검색\n정적 분석 Tool 활용하여 String 확인 IDA,jadx 등 Tool을 활용하여 디컴파일한 소스코드 내 String 검색\n대응 방안\n 서비스에 사요되지 않는 개발용 서버정보들을 소스 코드에서 삭제 관리자 계정 정보 등 하드코딩 되어있는 인증 정보들은 소스 코드에서 삭제  진단 시 주의사항 및 팁\n 실제로 통신하는 서버 정보는 App에 들어가 있을 수 밖에 없기때문에 이를 보고 취약하다고 판단해서는 안됨 정적 분석 과정 중에서만 이 부분을 체크한다면 부석하지 못한 함수가 발생할 수 있으니, App 바이너리에서 String들을 한번씩 꼭 확인해볼 필요가 있음   단말기 내 사용자 정보 저장  App 폴더 및 외부 저장소에 존재하는 파일 내에 사용자의 인증정보 및 개인정보들이 평문 또는 취약한 암호로 저장되어 노출됨\n주요 노출 정보  Search File : .db, shared_prefs, cache 등 개인정보 계정정보(자동로그인) 인증정보 암/복호화 키  진단 방법  SharedPreference SD Card 안전하지 않은 외부 저장소 클립보드, 자동완성 정보 입력 후 변경된 파일 확인 명령어 팁  대응 방안  androidallowbackup 설정 Keystore 사용하여 안전한 키관리 자동완성, 클립보드 (서비스 영향도 파악하여 설정 고려)  진단 시 주의 사항 및 팁  단말기 내 알지 못하는 파일들로 중요 정보가 저장될 수 있으므로 파일 수정 시간을 체크하여 해당 취약점이 누락되지 않도록 점검해야함 중요 정보가 암호화 되어있어 보여도, MD5 디코딩으로 평무닝 되거나 복호화 키가 단말기 안전하지 않은 영역에 저장되어 있을 경우가 있음   메모리 내 중요 정보 노출  이용자 단말기 메모리 내 개인정보 등 중요한 정보들이 평문 또는 취약한 암호화로 저장되어 노출됨\n주요 노출 중요 정보  String Keyword : jumin, token, user, password, key 등 개인정보 계정정보(자동로그인) 인증정보 암/복호화 키  진단 방법 (메모리 덤프) Am : am을 사용하여 메모리 덤프  android:debuggable=“true” 설정 확인 (False일 경우 수정하여 진단) \n메모리 덤프  \nstrings을 이용한 문자열 추출  \nFridump : frida를 사용하여 메모리 덤프 대응 방안  중요 정보를 입력 받는 경우 가상 키패드를 사용하여 사용자의 입력부터 암호화를 적용해 데이터를 보호해야됨 주요 정보 및 개인정보의 경우 사용된 후 바로 메모리에서 사리질 수 있도록 화면이 넘어가기 전 해당 내용을 다른 내용으로 덮어쓰기 웹 Response에서 노출되는 중요 정보들은 웹 Response에서 중요 정보들이 마스킹 되어 응답 되도록 수정하는 것을 ㅗ해당 취약점을 보완할 수 있음  진단 시 주의 사항 및 팁  사용자의 개인 정보, 중요 정보를 일반 키패드로 입력을 받고 있는 경우 메모리에 노출되고 있을 가능성이 크기 때문에 주의해서 확인해 봐야함 (주민등록번호, 인증번호, 비밀번호 등) 웹 Response도 메모리에 작성되기 때문에 웹 Response에서 중요 정보가 포함되어 있는지 확인해 봐야함   네트워크에서의 정보 노출  네트워크 통신 상에서 중요정보가 평문으로 노출되는 경우\n주요 노출 중요 정보  Search Keyword : ip, port, user, password, key 등 계정정보(ID,PW) 인증정보 개인정보 서버 중요정보  진단 방법  Tcpdump Proxy tool -\u0026gt; http 통신 분석  대응 방안  주요 정보를 주고 받을 때는 평문으로 노출되지 않도록 암호화 통신을 적용해야 함  주의 사항 및 팁  HTTPS 통신의 경우 암호화가 적용되어 데이터가 전달됙 때문에 인증서가 설치되어 있기 때문에 Proxy Tool을 이용해 평문으로 보인다고 취약하다고 판단해서는 안됨 Proxy Tool을 이용해 취약점을 확인하여도 tcpdump 등 네트워크 패킷을 캡쳐하여 실제로 네트워크 구간에서 평문으로 오가는지 확인해야함   백그라운드 화면 정보 노출  앱이 백그라운드 모드로 전환될 때 저장되는 스크린샷에서 개인의 정보가 평문으로 노출될 수 있음\n주요 노출 중요 정보  Search Keyword : 화면에 노출되는 개인정보 개인정보 인증정보  진단 방법  앱을 백그라운드 모드로 전환한 뒤 화면이 보호되는지 확인 화면이 보호되지 않고 있다면 단말기에 저장된 이미지 추출  대응 방안  백그라운드로 전환될 때 임의 지정한 사진 파일이 저장 될 수 있도록 변경해야함 ex) FLAG_SECURE 사용  주의 사항 및 팁  백그라운드 전환 후 이미지 파일을 추출하여 고객사에게 설명 (개인정보 포함되서 보이는 이미지) 백그라운드 스냅샷 경로는 기기 혹은 OS 버전 별로 다를 수 있음   \n 디버그 로그에서의 정보 노출  개발자들이 개발 중 디버깅을 위한 용도로 찍느 ㄴ로그에 개발 서버 정보나 곤리자 서버 주소 등 서버에 민감하고 중요한 정보들이 노출됨\n주요 노출 중요 정보  string keyword : ip, port, user, password, key, http 등 계정정보(ID/PW) 개인정보 함수 실행 Flow 및 인자, 리턴값 연동된 서버정보  진단 방법  Logcat Log.* 함수 분석 (log.d, log.e 등등)   \n대응 방안  디버그 로그로 출력되는 중요 정보들을 직접 삭제 debuggable 설정을 flase로 배포(release 모드로 배포)  주의사항 및 팁  debuggable 옵셜을 true로 바꿔 리패키징한 뒤 디버그 로그 진단 하지 말아야함. debuggable 옵션을 true로 의도적으로 바꿀경우 디버그 로그가 출력되는 것은 당연함, 하지만 서버정보 중요 정보가 노출되는지 확인 하기 위해서는 필요함  ","date":"2022-04-01T05:16:13+09:00","permalink":"https://kazal92.github.io/android/information_disclosure/","title":"Android App 정보노출 진단"},{"content":"APK 추출 백업 기능을 이용해서 추출 ASTRO 파일 관리자 설치\nhttps://drive.google.com/file/d/1DWBTDjP1HQDAGszkn5fvNkzj0RP0xKnd/view?usp=sharing 앱 \u0026gt; 추출할 앱 선택(쭉) \u0026gt; 백업\n$ adb shell $ cd /sdcard/backups/apps -\u0026gt; 백업된 앱 경로 및 파일명 확인  $ adb pull /sdcard/backups/apps/jakhar.aseem.diva.apk    \nARM 이란? CISC vs RISC Advanced RISC Machine의 약자 CPU TYPE  \nARM 모드 / Thumb 모드Í  ARM 과 x86 의 가장 큰 차이점은 Thumb 모드가 있다는 것 THUMB 모드는 32bit ARM에서 동작하는 16bit 기계어  ARM 모드 ←→ Thumb 모드 BLX / BX 등 X로 끝나는 분기문 명령으로 모드 전환  \n","date":"2022-04-01T04:15:11+09:00","permalink":"https://kazal92.github.io/android/app_analyze/","title":"Android App 분석"},{"content":"타입 I – int J – long Z – Boolean D – double F – float S – short C – char V - void 메소드 종류 Static : this 인수가 암묵적으로 첫번째 인수로 전달되지 않으면, Static 메소드\nDirect : vtable 개입 없이 직접 invoke 함 (ex. private method, constructor)\nVirtual : 자식 클래스에서 override 될 수 있는 Virtual 메소드. 클래스 관련됨 vtable을 사용해 invoke 함\nRegister 간 데이터 이동 move move/from16 move-wide move-wide/from16 move-object move-object/from16 리턴 세팅 및 처리 move-result move-result-wide move-result-object return-void return return-wide return-object 예외 처리 throw move-exception 레지스터에 상수 대입 const/4 const 인스트럭션 패밀리\n레지스터간 move move, move/from16, move-wide, move-wide/from16, move-object, move-object/from16 결과값을 얻거나 세팅 move-result, move-result-wide, move-result-object, return-void, return, return-wide, return-object 예외처리 throw, move-exception 레지스터에 상수 대입 const/4, const/16, const, const/high16, const-wide/1, const-wide/32, const-wide, const-wide/high16, const-string, const-class 동기화 monitor-enter, monitor-exit 타입체크 check-cast, instance-of 배열 조작 new-array, array-length, filled-new-array, filled-new-array/range, fill-array-data 인스턴스생성 new-instance 실행 조작 goto, goto/16, packed-switch, sparse-switch, if-eq, if-ne, if-lt, if-ge, if-gt, if-le, if-eqz, if-nez, if-ltz, if-gez, if-gtz, if-lez 비교 cmpl-float cmpg-float cmpl-double cmpl-double cmpg-double cmp-long 멤버필드에 읽기/쓰기 iget iget-wide iget-object iget-boolean iget-byte iget-char iget-short 배열요소에 읽기/쓰기 aget aget-wide aget-object aget-boolean aget-byte aget-char aget-short 메소드 호출 invoke-virtua invoke-super invoke-direct invoke-static invoke-interface invoke-virtual/range invoke-super/range invoke-direct/range invoke-static/range invoke-interface/range 연산 명령(int, long, float, double) add sub mul div rem Smali snippet so 라이브러리 로드 const-string v0, \u0026#34;so_file_name\u0026#34; invoke-static {v0}, Ljava/lang/System;-\u0026gt;loadLibrary(Ljava/lang/String;)V 로그 출력 .local v0, \u0026#34;Log\u0026#34;:Ljava/lang/String; const-string v1, \u0026#34;hack\u0026#34; //출력할 문자열 혹은 레지스터 invoke-static {v1, v0}, Landroid/util/Log;-\u0026gt;e(Ljava/lang/String;Ljava/lang/String;)I sleep const-wide/16 v2, 0xa // 0xa = 10 invoke-static {v2, v3}, Ljava/lang/Thread;-\u0026gt;sleep(J)V toast 출력 const-string v0, \u0026#34;Toast TEST\u0026#34; const/4 v1, 0x0 invoke-static {p0, v0, v1}, Landroid/widget/Toast;-\u0026gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast; move-result-object v0 invoke-virtual {v0}, Landroid/widget/Toast;-\u0026gt;show()V ","date":"2022-04-01T03:06:10+09:00","permalink":"https://kazal92.github.io/android/smali_code/","title":"smali code"},{"content":"Android 보안 솔루션  루팅 탐지   공격자들의 App 분석 및 공격을 방해하기 위해 탐지 사용자들에게 해당 App이 루팅된 기기에서 실행될 경우 위험하다는 것을 경고하기 위해 탐지 (특히, 금융App)  루팅 탐지 원리 루팅이 되었을 때 나타나는 특징들을 확인하여 루팅을 탐지\n \n루팅 탐지 방법  설치된 package 확인 루팅했을 때 설치되는 App이 존재하는지 확인하여 루팅 탐지 pm을 이용하여 확인   \n파일 확인\n su binary, busybox 등 파일 확인   \nbuild.prop 파일에서 기본값 확인\n 루팅을 하게 되면 /system/build.prop 파일에 test-keys로 설정 되어 있는 것을 확인 안드로이드에서 ro.build.tag 릴리즈 키로 설정되어 있는데 루팅을 한경우 test-keys로 설정됨   \nDirectory Permission 확인\n system directory 등의 디렉토리의 권한을 변경했는지 체크   \n마운트 정보를 확인하여 rw 권한을 확인, 테스트 파일을 임의 경로로 생성하여 생성이 되는지 확인\n \n 무결성 검증   Anti-Debugging   문자열 난독화   Mobile Solution Trick  1. Decompile 방해 decompile tool이 정상적으로 동적하지 못하도록해 분서을 어렵게 만듬\nex) Invlid fill-array-data trick, Trunchted method trick\n \n대처 방법 → tool의 smali version update\n→ truncated method를 무시하도록 nop 코드로 치환\n2. Repackaging 방해 → Repackaging을 방해하여 App을 쉽게 변조하지 못하도록 함\nex) AndroidManifest.xml 변조, Bad Resouce\n \n대처 방법 → AndroidManifest.xml 의 난돋화된 이름 속성값을 바이너리로 변환\n→ Bad Resouce를 정상 Resource로 교체\n3. Dex 암호화 및 동적 로딩 → 고객의 코드를 보호하기 위해 DEX 또는 .so 파일을 암호화하여 저장한 뒤, 앱이 실행될 때 다음 API들을 이용하여 동적으로 로드함\nDexClassLoader(Dalvik), BaseDexClassLoader\nPatchClassLoader(ART)\ndlopen(Native shared object)\n대처 방법  → Low Level API 함수를 후킹하여 DEX / .so 파일 가로채기 DexFileLoader, OpenCommon, OpenAndReadMagic, dlopen → File Deletion 함수 후킹하여 삭제 막기 unlink call을 후킹하여 파일 삭제를 막을 수 있음  4. Frida, remote debugging 탐지 (socket check) → Frida를 탐지하기 위해 Frdia-server가 열어놓은 포트를 확인 → 직접 해당포트에 연결해보는 방법으로 확인\n대처 방법  → 소켓 연결 함수 후킹 소켓 연결하는 함수를 후킹하여 연결에 실패하도록 변조  5. 코드 흐름 난독화 → 실행되는 코드의 흐름을 난독화하여 분석을 방해함  \n대처 방법 → 불필요한 쓰레기 더미 코드들을 제거하며 분석\n","date":"2022-03-30T23:39:15+09:00","permalink":"https://kazal92.github.io/android/android-%EB%B3%B4%EC%95%88-%EC%86%94%EB%A3%A8%EC%85%98/","title":"Android 보안 솔루션"},{"content":" \nArchitecture Linux Kernel 내용 추가~!!\nAndroid Runtime  AOT(Ahead Of Time), JIT(Just In Time) 컴파일 최적화된 GC(Garbage Collector : 메모리 관리)  달빅 VM(Dalvick Virtual Machine)과 ART(Ahead Of Time)\n Andorid는 기본 언어를 JAVA를 사용하기 때문에 JVM 역할을 할 수 있는 VM 필요 안드로이드 구조에 최적화 시켜 만든 달빅 VM과 ART 가상머신이 dex 포맷의 바이트코드를 해석하여 안드로이드 어플리케이션을 실행하게 된다.   JIT(Just In Time)\n어플리케이션 구동 시 실시간으로 자바코드로 변환하며, 자바코드 일정부분 RAM 상에 상주\n장점 : 성능적으로 크게 향상됨\n단점 : JIT 컴파일러 구동 시 하드웨어에 부하가 크게 발생하며, 다른 방식에 비해 RAM 사용량 증가\n  ART(Ahead Of Time)\n어플리케이션 설치 시 한 번에 컴파일하여 바이트 코드로 변환하여, 실행 시 변환된 코드를 사용 sdfii\n장점 : 성능적으로 크게 향상됨\n단점 : 설치 공간이 달빅VM에 비해 약 1.5~2배 가량 더 필요하며, 설치 시간이 오래걸림\n Native Libraries ART 및 HAL등의 많은 핵심 Android 시스템 구성 요소와 서비스는 C 및 C++로 작성된 네이티브 라이브러리를 필요로 하는 네이티브 코드 기반으로 빌드 되어 있음\n NDK(Native Development Kit)\n C/C++(Native Code) 등의 언어로 앱 일부를 구현할 수 있는 도구 C/C++로 구현된 코드를 Android에서 사용될 수 있는 Library나 Binary로 만들어 주는 도구    JNI(Java Native Interface)\n Java 코드에서 C/C++로 만들어진 Library를 가능하게 해주는 인터페이스 제공 Java 코드에 Native 함수를 선언하면, Java Library 파일(.so)에서 매핑 되는 함수를 찾음   NDK \u0026amp; JNI 연동\nJNI 정보를 담고 있는 JNI_OnLoad() 함수가 로드하려는 labrary 파일 안에 구현되어 있을경우 수동매핑, 구현되어 있지 않은 경우 자동 매핑이 이루어짐\n자동매핑 : JNI_Onload() 함수가 없으면 DVM은 자동으로 라이브러리 내에 JNI Native 함수들을 비교해 매핑 작업을 수행 후 매핑된 함수 호출, 매핑 작업으로 인해 성능 저하의 원인이 됨\n수동매핑 : JNI_Onlod() 함수가 구현되어 있어 구현된 정보에 맞는 함수 호출, 개발자가 직접 연결해주는 작업이 필요하며 로딩 속도를 향상 시킬 수 있음\n \nAndroid Framework Build 윈도우 실행파일이 PE파일인 것처럼, 안드로이드의 실행파일은 dex이다.\n안드로이드는 dex파일을 달빅이라는 가상머신에서 구동 시킨다.\n달빅 가상머신은 모바일 기기에서 메모리를 적게 사용하면서 실행파일이 구동되도록 모바일에 최적화된 가상머신이다.\nOS에 하나가 있는 것이 아니라 어플리케이션마다 달빅가상머신이 생성되는 형태이다.(샌드박스 형식) . apk 개발을 위해 작성한 java코드를 컴파일한 클래스 파일(자바바이트 코드)을 dx 툴로 변환하면 dex(달빅바이트코드) 파일이 생성된다.\njava code → java bytecode → dex bytecode\n그리고 dx툴로 변환하는 과정에서 java의 바이트 코드(.class)가 달빅바이트코드(.dex)로 변환된다\n DEX (Dalvik Excutable)\nAndroid 어플리케이션은 Dalvik VM에서 더 효과적으로 실행되기 위해 개발자가 JDK로 코드를 컴파일 하여 만든 바이트 코드는 Dalvik VM에서 DEX파일로 변환되어 실행됨\n  Smali Code\n 달빅 바이트 코드를 위한 어셈블리 언어, DEX 바이너리를 사람이 읽기 편하게 표현한 언어 재컴파일이 가능하므로 원하는 부분을 수정하여 코드 패칭이 가능하다.    https://sudeky.tistory.com/30 \n코드 서명  앱 개발자가 누구인지 나타내기 위해 개발자가 자신의 코드서명인증서로 서명을 하는 것 악의적인 사용자가 패치한 앱의 배포를 막기 위해 private key가 탈취 당했을경우 앱스토어에 App의 업그레이드 버전으로 배포가 가능해서 키관리 주의   \nAPK 구조  \nAndoridManifest.xml 아래와 같은 App에 대한 정보가 명시되어 있음\n 고유한 패키지 이름 Activity, Service, Broadcast Receiver, Instrumentation Definiton 권한 정의 (응용 프로그램이 요청한 권한 및 사용자 정의 모두) 응용 프로그램과 함께 패키지 되어 사용되는 외부 라이브러리에 대한 정보 공유 UID 정보, 기본 설치 위치 및 UI 정보   공유 UID\n 두 개 이상의 어플리케이션에서 동일한 사용자 식별자 지정이 가능함 이 경우 앱들은 동일한 UID에서 실행되는데, 이를 통해 동일 UID를 가진 앱은 잠재적으로 서로 리소스에 접근 가능   Activity  사용자와 상호작용하기 위한 진입점으로 UI를 포함한 화면 하나를 나타냄 사용자가 현재 관심을 가지고 있는 화면을 추적하여 계속 실행하게 함 Activity Manager에서 위와 같은 일들을 처리함   \n Activity 생명주기 (Life Cycle) \nService 백그라운드에서 앱을 계속 실행하기 위한 다목적 진입점으로 백그라운등서 실행되며 오랫동안 실행되는 작업을 수행하거나 원격 프로세스를 위한 작업을 수행\n \nBroadcast Receiver 시스템이 정기적인 사용자 플로우 밖에서 이벤트를 앱에 전달하도록 지원하며, 앱이 시스템 전체의 브로드캐스트 알림에 응답할 수 있도록 도와줌\n \nContent Providers 파일 시스템, SQLite DB, 웹상이나 앱이 액세스할 수 있는 다른 모든 영구 저장 위치에 저장 가능한 앱 데이터의 공유에 있어 읽기, 쓰기 권한 관리 역할, Content Providers를 구성하여 다른 어플리케이션들과 안전하게 데이터 공유가 가능함  \n \nAndoridManifest.xml 간단한 분석 앱 진단 전에 확인하여 앱이 어떤 동작을 하는지 유추 해볼 수 있다.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; standalone=\u0026#34;no\u0026#34;?\u0026gt;\u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; package=\u0026#34;jakhar.aseem.diva\u0026#34; platformBuildVersionCode=\u0026#34;23\u0026#34; platformBuildVersionName=\u0026#34;6.0-2166767\u0026#34;\u0026gt;  \u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_EXTERNAL_STORAGE\u0026#34;/\u0026gt; //외부 저장소(sd카드) 쓰기 권한 // 안드로이드 패키지 이름  \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_EXTERNAL_STORAGE\u0026#34;/\u0026gt; // 외부 저장소(sd카드) 읽기 권한  \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34;/\u0026gt; // 외부와 통신 하는 권한  \u0026lt;application android:allowBackup=\u0026#34;true\u0026#34; android:debuggable=\u0026#34;true\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:supportsRtl=\u0026#34;true\u0026#34; android:theme=\u0026#34;@style/AppTheme\u0026#34;\u0026gt;  ㄴ백업허용\tㄴdebugable=\u0026#34;true\u0026#34; 디버깅이 가능함 취약한 설정, \u0026lt;activity android:label=\u0026#34;@string/app_name\u0026#34; android:name=\u0026#34;jakhar.aseem.diva.MainActivity\u0026#34; android:theme=\u0026#34;@style/AppTheme.NoActionBar\u0026#34;\u0026gt;  \u0026lt;intent-filter\u0026gt;  \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34;/\u0026gt;. // 이 속성이 들어가있는 액티비티는 앱에서 가장 먼저 실행되는 액티비티이다. -\u0026gt; jakhar.aseem.diva.MainActivity  \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34;/\u0026gt;  \u0026lt;/intent-filter\u0026gt;  \u0026lt;/activity\u0026gt;  \u0026lt;activity android:label=\u0026#34;@string/d1\u0026#34; android:name=\u0026#34;jakhar.aseem.diva.LogActivity\u0026#34;/\u0026gt;  \u0026lt;activity android:label=\u0026#34;@string/d2\u0026#34; android:name=\u0026#34;jakhar.aseem.diva.HardcodeActivity\u0026#34;/\u0026gt;  \u0026lt;activity android:label=\u0026#34;@string/d3\u0026#34; android:name=\u0026#34;jakhar.aseem.diva.InsecureDataStorage1Activity\u0026#34;/\u0026gt;  \u0026lt;activity android:label=\u0026#34;@string/d4\u0026#34; android:name=\u0026#34;jakhar.aseem.diva.InsecureDataStorage2Activity\u0026#34;/\u0026gt;  \u0026lt;activity android:label=\u0026#34;@string/d5\u0026#34; android:name=\u0026#34;jakhar.aseem.diva.InsecureDataStorage3Activity\u0026#34;/\u0026gt;  \u0026lt;activity android:label=\u0026#34;@string/d6\u0026#34; android:name=\u0026#34;jakhar.aseem.diva.InsecureDataStorage4Activity\u0026#34;/\u0026gt;  \u0026lt;activity android:label=\u0026#34;@string/d7\u0026#34; android:name=\u0026#34;jakhar.aseem.diva.SQLInjectionActivity\u0026#34;/\u0026gt;  \u0026lt;activity android:label=\u0026#34;@string/d8\u0026#34; android:name=\u0026#34;jakhar.aseem.diva.InputValidation2URISchemeActivity\u0026#34;/\u0026gt;  \u0026lt;activity android:label=\u0026#34;@string/d9\u0026#34; android:name=\u0026#34;jakhar.aseem.diva.AccessControl1Activity\u0026#34;/\u0026gt;  \u0026lt;activity android:label=\u0026#34;@string/apic_label\u0026#34; android:name=\u0026#34;jakhar.aseem.diva.APICredsActivity\u0026#34;\u0026gt;  \u0026lt;intent-filter\u0026gt;  \u0026lt;action android:name=\u0026#34;jakhar.aseem.diva.action.VIEW_CREDS\u0026#34;/\u0026gt;  \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt;  \u0026lt;/intent-filter\u0026gt;  \u0026lt;/activity\u0026gt;  \u0026lt;activity android:label=\u0026#34;@string/d10\u0026#34; android:name=\u0026#34;jakhar.aseem.diva.AccessControl2Activity\u0026#34;/\u0026gt;  \u0026lt;activity android:label=\u0026#34;@string/apic2_label\u0026#34; android:name=\u0026#34;jakhar.aseem.diva.APICreds2Activity\u0026#34;\u0026gt;  \u0026lt;intent-filter\u0026gt;  \u0026lt;action android:name=\u0026#34;jakhar.aseem.diva.action.VIEW_CREDS2\u0026#34;/\u0026gt;  \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt;  \u0026lt;/intent-filter\u0026gt;  \u0026lt;/activity\u0026gt;  \u0026lt;provider android:authorities=\u0026#34;jakhar.aseem.diva.provider.notesprovider\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34; android:name=\u0026#34;jakhar.aseem.diva.NotesProvider\u0026#34;/\u0026gt;  // provider 에 exported=\u0026#34;true\u0026#34; 이면 외부 앱에서 이 프로바이더를 사용할 수 있음, 프로바이더의 적절한 권한 설정되어 있는지 확인해야한다.  \u0026lt;activity android:label=\u0026#34;@string/d11\u0026#34; android:name=\u0026#34;jakhar.aseem.diva.AccessControl3Activity\u0026#34;/\u0026gt;  \u0026lt;activity android:label=\u0026#34;@string/d12\u0026#34; android:name=\u0026#34;jakhar.aseem.diva.Hardcode2Activity\u0026#34;/\u0026gt;  \u0026lt;activity android:label=\u0026#34;@string/pnotes\u0026#34; android:name=\u0026#34;jakhar.aseem.diva.AccessControl3NotesActivity\u0026#34;/\u0026gt;  \u0026lt;activity android:label=\u0026#34;@string/d13\u0026#34; android:name=\u0026#34;jakhar.aseem.diva.InputValidation3Activity\u0026#34;/\u0026gt;  \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; ","date":"2022-03-30T00:00:00Z","permalink":"https://kazal92.github.io/android/","title":"Android 구조와 동작원리"}]